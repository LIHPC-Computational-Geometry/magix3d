//
// Created by calderans on 3/17/25.
//

#include "Topo/ExportBlocksImplementation.h"
#include "Topo/EdgeMeshingPropertyGeometric.h"
#include "Topo/EdgeMeshingPropertyGlobalInterpolate.h"
/*----------------------------------------------------------------------------*/
namespace Mgx3D {
/*----------------------------------------------------------------------------*/
namespace Topo {
/*----------------------------------------------------------------------------*/
ExportBlocksImplementation::
ExportBlocksImplementation(Internal::Context& c, const std::string& n)
: m_context(c), m_filename(n)
{}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::perform(Internal::InfoCommand* icmd)
{

    std::ofstream str(m_filename, std::ios::out);
    if (!str){
        std::string s ="Impossible to create a Blocking File: "+m_filename;
        throw TkUtil::Exception (TkUtil::UTF8String (s));
    }

    str << "# Mgx DataFile Version 0.1\n";
    str << "Generated by Mgx Writer\n\n";
    str << "ASCII\n";
    
    Mgx3D::Topo::TopoManager& tm = m_context.getTopoManager();

    std::vector<Topo::Vertex*> vertices = tm.getVerticesObj();
    writeNodes(str, vertices);

    std::vector<CoEdge*> edges = tm.getCoEdgesObj();
    writeEdges(str, edges);

    std::vector<CoFace*> faces = tm.getCoFacesObj();
    writeFaces(str, faces);

    std::vector<Block*> blocks = tm.getBlocksObj();
    writeBlocks(str, blocks);

    str.close();
}
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::writeNodes(std::ofstream &str, std::vector<Topo::Vertex*> vertices) {
        str  << "POINTS " << vertices.size() << "\n";

        auto blk_node_id = 0;
        for(auto v : vertices){
            Utils::Math::Point p = v->getCoord();
            str << p.getX() <<  " " << p.getY() << " " << p.getZ() << "\n";
            m_node_ids_mapping[v->getName()] = blk_node_id++;
        }
        str  <<"\n\n";
}
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::writeEdges(std::ofstream &str, std::vector<Topo::CoEdge*> edges) {
        str  << "EDGES " << edges.size() << "\n";

        auto blk_edge_id = 0;
        for(auto e : edges){
            int n0 = m_node_ids_mapping[e->getVertex(0)->getName()];
            int n1 = m_node_ids_mapping[e->getVertex(1)->getName()];
            str << n0 <<  " " << n1 << "\n";
            m_edge_ids_mapping[e->getName()] = blk_edge_id++;
        }
        str  << "Discr " << edges.size() << "\n";
        for(auto e : edges){

            CoEdgeMeshingProperty* prop = e->getMeshingProperty();
            switch (prop->getMeshLaw()) {
                case CoEdgeMeshingProperty::uniforme:
                    str << 0 <<  " " << prop->getNbEdges() << "\n";
                    break;
                case CoEdgeMeshingProperty::geometrique:
                    str << 1 <<  " " << prop->getNbEdges() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyGeometric*>(prop)->getRatio() << "\n";
                    break;
                case CoEdgeMeshingProperty::bigeometrique:
                    str << 2 <<  " " << prop->getNbEdges() << "\n";
                    break;
                case CoEdgeMeshingProperty::hyperbolique:
                    str << 3 <<  " " << prop->getNbEdges() << "\n";
                    break;
                case CoEdgeMeshingProperty::specific_size:
                    str << 4 <<  " " << prop->getNbEdges() << "\n";
                    break;
                case CoEdgeMeshingProperty::interpolate:
                    str << 5 <<  " " << prop->getNbEdges() << "\n";
                    break;
                case CoEdgeMeshingProperty::globalinterpolate:

                    str << 6 <<  " " << prop->getNbEdges() << " [ ";
                    for(auto e_name : dynamic_cast<EdgeMeshingPropertyGlobalInterpolate*>(prop)->getFirstCoEdges()){
                        str << m_edge_ids_mapping[e_name] << " ";
                    }
                    str << "] [ ";
                    for(auto e_name : dynamic_cast<EdgeMeshingPropertyGlobalInterpolate*>(prop)->getSecondCoEdges()){
                        str << m_edge_ids_mapping[e_name] << " ";
                    }
                    str << "] " << "\n";
                    break;
                case CoEdgeMeshingProperty::tabulated:
                    str << 7 <<  " " << prop->getNbEdges() << "\n";
                    break;
                case CoEdgeMeshingProperty::beta_resserrement:
                    str << 8 <<  " " << prop->getNbEdges() << "\n";
                    break;
                default:
                    std::string s ="Arete avec une méthode de discrétisation inconnue";
                    throw TkUtil::Exception(TkUtil::UTF8String (s));
            }
        }
        str  <<"\n\n";
}
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::writeFaces(std::ofstream &str, std::vector<Topo::CoFace*> faces) {
        str  << "FACES " << faces.size() << "\n";
        auto blk_face_id = 0;
        for(auto f : faces){


            m_face_ids_mapping[f->getName()] = blk_face_id++;
            Edge* e0 = f->getEdge(0);
            Edge* e1 = f->getEdge(1);
            Edge* e2 = f->getEdge(2);
            Edge* e3 = f->getEdge(3);

            str << "[ ";

            if(f->getVertex(0)->getName() == e0->getVertex(0)->getName()) {
                for (int i = 0; i < e0->getCoEdges().size(); i++)
                    str << m_edge_ids_mapping[e0->getCoEdge(i)->getName()]<<" ";
            }else if(f->getVertex(0)->getName() == e0->getVertex(1)->getName()){
                for (int i = e0->getCoEdges().size()-1; i >= 0 ; i--)
                    str << m_edge_ids_mapping[e0->getCoEdge(i)->getName()]<<" ";
            }
            str << "] [ ";

            if(f->getVertex(1)->getName() == e1->getVertex(0)->getName()) {
                for (int i = 0; i < e1->getCoEdges().size(); i++)
                    str << m_edge_ids_mapping[e1->getCoEdge(i)->getName()]<<" ";
            }else if(f->getVertex(1)->getName() == e1->getVertex(1)->getName()){
                for (int i = e1->getCoEdges().size()-1; i >= 0 ; i--)
                    str << m_edge_ids_mapping[e1->getCoEdge(i)->getName()]<<" ";
            }
            str << "] [ ";

            if(f->getVertex(2)->getName() == e2->getVertex(0)->getName()) {
                for (int i = 0; i < e2->getCoEdges().size(); i++)
                    str << m_edge_ids_mapping[e2->getCoEdge(i)->getName()]<<" ";
            }else if(f->getVertex(2)->getName() == e2->getVertex(1)->getName()){
                for (int i = e2->getCoEdges().size()-1; i >= 0 ; i--)
                    str << m_edge_ids_mapping[e2->getCoEdge(i)->getName()]<<" ";
            }
            str << "] [ ";

            if(f->getVertex(3)->getName() == e3->getVertex(0)->getName()) {
                for (int i = 0; i < e3->getCoEdges().size(); i++)
                    str << m_edge_ids_mapping[e3->getCoEdge(i)->getName()]<<" ";
            }else if(f->getVertex(3)->getName() == e3->getVertex(1)->getName()){
                for (int i = e3->getCoEdges().size()-1; i >= 0 ; i--)
                    str << m_edge_ids_mapping[e3->getCoEdge(i)->getName()]<<" ";
            }
            str << "]\n";
        }
        str << "\n";
}
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::writeBlocks(std::ofstream &str, std::vector<Topo::Block*> blocks) {
        str  << "BLOCKS " << blocks.size() << "\n";
        for(auto b : blocks){

            int v0 = m_node_ids_mapping[b->getVertex(0)->getName()];
            int v1 = m_node_ids_mapping[b->getVertex(1)->getName()];
            int v2 = m_node_ids_mapping[b->getVertex(2)->getName()];
            int v3 = m_node_ids_mapping[b->getVertex(3)->getName()];
            int v4 = m_node_ids_mapping[b->getVertex(4)->getName()];
            int v5 = m_node_ids_mapping[b->getVertex(5)->getName()];
            int v6 = m_node_ids_mapping[b->getVertex(6)->getName()];
            int v7 = m_node_ids_mapping[b->getVertex(7)->getName()];

            Face* f0 = b->getFace(0);
            Face* f1 = b->getFace(1);
            Face* f2 = b->getFace(2);
            Face* f3 = b->getFace(3);
            Face* f4 = b->getFace(4);
            Face* f5 = b->getFace(5);

            str << v0 << " " << v1 << " " << v2 << " " << v3 << " " << v4 << " ";
            str << v5 << " " << v6 << " " << v7 << " [ ";
            for (int i = 0; i < f0->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f0->getCoFace(i)->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f1->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f1->getCoFace(i)->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f2->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f2->getCoFace(i)->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f3->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f3->getCoFace(i)->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f4->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f4->getCoFace(i)->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f5->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f5->getCoFace(i)->getName()]<<" ";
            str << "]\n";
        }
}
/*----------------------------------------------------------------------------*/
} // end namespace Geom
/*----------------------------------------------------------------------------*/
} // end namespace Mgx3D
/*----------------------------------------------------------------------------*/