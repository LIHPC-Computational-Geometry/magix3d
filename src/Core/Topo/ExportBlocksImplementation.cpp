//
// Created by calderans on 3/17/25.
//

#include "Topo/ExportBlocksImplementation.h"
#include "Topo/EdgeMeshingPropertyGeometric.h"
#include "Topo/EdgeMeshingPropertyGlobalInterpolate.h"
#include "Topo/EdgeMeshingPropertyBigeometric.h"
#include "Topo/EdgeMeshingPropertyHyperbolic.h"
#include "Topo/EdgeMeshingPropertySpecificSize.h"
#include "Topo/EdgeMeshingPropertyInterpolate.h"
#include "Topo/EdgeMeshingPropertyBeta.h"
/*----------------------------------------------------------------------------*/
namespace Mgx3D {
/*----------------------------------------------------------------------------*/
namespace Topo {
/*----------------------------------------------------------------------------*/
ExportBlocksImplementation::
ExportBlocksImplementation(Internal::Context& c, const std::string& n)
: m_context(c), m_filename(n)
{}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::perform(Internal::InfoCommand* icmd)
{

    std::ofstream str(m_filename, std::ios::out);
    if (!str){
        std::string s ="Impossible to create a Blocking File: "+m_filename;
        throw TkUtil::Exception (TkUtil::UTF8String (s));
    }

    str << "# Mgx DataFile Version 0.1\n";
    str << "Generated by Mgx Writer 2.5.0\n\n";
    str << "ASCII\n";
    
    Mgx3D::Topo::TopoManager& tm = m_context.getTopoManager();

    std::vector<Topo::Vertex*> vertices = tm.getVerticesObj();
    writeNodes(str, vertices);

    std::vector<CoEdge*> edges = tm.getCoEdgesObj();
    writeEdges(str, edges);

    std::vector<CoFace*> faces = tm.getCoFacesObj();
    writeFaces(str, faces);

    std::vector<Block*> blocks = tm.getBlocksObj();
    writeBlocks(str, blocks);

    str.close();
}
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::writeNodes(std::ofstream &str, std::vector<Topo::Vertex*> vertices) {
        str  << "POINTS " << vertices.size() << "\n";

        auto blk_node_id = 0;
        for(auto v : vertices){
            Utils::Math::Point p = v->getCoord();
            str << p.getX() <<  " " << p.getY() << " " << p.getZ() << "\n";
            m_node_ids_mapping[v->getName()] = blk_node_id++;
        }
        str  <<"\n\n";
}
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::writeEdges(std::ofstream &str, std::vector<Topo::CoEdge*> edges) {
        str  << "EDGES " << edges.size() << "\n";

        auto blk_edge_id = 0;
        for(auto e : edges){
            int n0 = m_node_ids_mapping[e->getVertices()[0]->getName()];
            int n1 = m_node_ids_mapping[e->getVertices()[1]->getName()];
            str << n0 <<  " " << n1 << "\n";
            m_edge_ids_mapping[e->getName()] = blk_edge_id++;
        }
        str  << "Discr " << edges.size() << "\n";
        for(auto e : edges){

            CoEdgeMeshingProperty* prop = e->getMeshingProperty();
            switch (prop->getMeshLaw()) {
                case CoEdgeMeshingProperty::uniforme:
                    str << 0 <<  " " << prop->getNbEdges() << "\n";
                    break;
                case CoEdgeMeshingProperty::geometrique:
                    str << 1 <<  " " << prop->getNbEdges() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyGeometric*>(prop)->getRatio() << "\n";
                    break;
                case CoEdgeMeshingProperty::bigeometrique:
                    str << 2 <<  " " << prop->getNbEdges() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyBigeometric*>(prop)->getRatio1() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyBigeometric*>(prop)->getLength1() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyBigeometric*>(prop)->getRatio2() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyBigeometric*>(prop)->getLength2() << "\n";
                    break;
                case CoEdgeMeshingProperty::hyperbolique:
                    str << 3 <<  " " << prop->getNbEdges() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyHyperbolic*>(prop)->getLength1() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyHyperbolic*>(prop)->getLength2() << "\n";
                    break;
                case CoEdgeMeshingProperty::specific_size:
                    str << 4 <<  " " << prop->getNbEdges() << " ";
                    str << dynamic_cast<EdgeMeshingPropertySpecificSize*>(prop)->getEdgeSize() << "\n";
                    break;
                case CoEdgeMeshingProperty::interpolate:
                    str << 5 <<  " " << prop->getNbEdges();
                    if(!dynamic_cast<EdgeMeshingPropertyInterpolate*>(prop)->getCoEdges().empty()){
                        str << " 0 [ ";
                        for(auto e_name : dynamic_cast<EdgeMeshingPropertyInterpolate*>(prop)->getCoEdges()){
                            str << m_edge_ids_mapping[e_name] << " ";
                        }
                    }else{
                        str << " 1 [ " << m_face_ids_mapping[dynamic_cast<EdgeMeshingPropertyInterpolate*>(prop)->getCoFace()] << " ";
                    }
                    str << "] " << "\n";
                    break;
                case CoEdgeMeshingProperty::globalinterpolate:

                    str << 6 <<  " " << prop->getNbEdges() << " [ ";
                    for(auto e_name : dynamic_cast<EdgeMeshingPropertyGlobalInterpolate*>(prop)->getFirstCoEdges()){
                        str << m_edge_ids_mapping[e_name] << " ";
                    }
                    str << "] [ ";
                    for(auto e_name : dynamic_cast<EdgeMeshingPropertyGlobalInterpolate*>(prop)->getSecondCoEdges()){
                        str << m_edge_ids_mapping[e_name] << " ";
                    }
                    str << "] " << "\n";
                    break;
                case CoEdgeMeshingProperty::tabulated:
                    str << 7 <<  " " << prop->getNbEdges() << "\n";
                    break;
                case CoEdgeMeshingProperty::beta_resserrement:
                    str << 8 <<  " " << prop->getNbEdges() << " ";
                    str << dynamic_cast<EdgeMeshingPropertyBeta*>(prop)->getBeta() << "\n";
                    break;
                default:
                    std::string s ="Arete avec une méthode de discrétisation inconnue";
                    throw TkUtil::Exception(TkUtil::UTF8String (s));
            }
        }
        str  <<"\n\n";
}
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::writeFaces(std::ofstream &str, std::vector<Topo::CoFace*> faces) {
        str  << "FACES " << faces.size() << "\n";
        auto blk_face_id = 0;
        for(auto f : faces){


            m_face_ids_mapping[f->getName()] = blk_face_id++;
            const std::vector<Edge*> f_edges = f->getEdges();
            Edge* e0 = f_edges[0];
            Edge* e1 = f_edges[1];
            Edge* e2 = f_edges[2];
            Edge* e3 = f_edges[3];

            str << "[ ";

            if(f->getVertices()[0]->getName() == e0->getVertices()[0]->getName()) {
                for (int i = 0; i < e0->getCoEdges().size(); i++)
                    str << m_edge_ids_mapping[e0->getCoEdges()[i]->getName()]<<" ";
            }else if(f->getVertices()[0]->getName() == e0->getVertices()[1]->getName()){
                for (int i = e0->getCoEdges().size()-1; i >= 0 ; i--)
                    str << m_edge_ids_mapping[e0->getCoEdges()[i]->getName()]<<" ";
            }
            str << "] [ ";

            if(f->getVertices()[1]->getName() == e1->getVertices()[0]->getName()) {
                for (int i = 0; i < e1->getCoEdges().size(); i++)
                    str << m_edge_ids_mapping[e1->getCoEdges()[i]->getName()]<<" ";
            }else if(f->getVertices()[1]->getName() == e1->getVertices()[1]->getName()){
                for (int i = e1->getCoEdges().size()-1; i >= 0 ; i--)
                    str << m_edge_ids_mapping[e1->getCoEdges()[i]->getName()]<<" ";
            }
            str << "] [ ";

            if(f->getVertices()[2]->getName() == e2->getVertices()[0]->getName()) {
                for (int i = 0; i < e2->getCoEdges().size(); i++)
                    str << m_edge_ids_mapping[e2->getCoEdges()[i]->getName()]<<" ";
            }else if(f->getVertices()[2]->getName() == e2->getVertices()[1]->getName()){
                for (int i = e2->getCoEdges().size()-1; i >= 0 ; i--)
                    str << m_edge_ids_mapping[e2->getCoEdges()[i]->getName()]<<" ";
            }
            str << "] [ ";

            if(f->getVertices()[3]->getName() == e3->getVertices()[0]->getName()) {
                for (int i = 0; i < e3->getCoEdges().size(); i++)
                    str << m_edge_ids_mapping[e3->getCoEdges()[i]->getName()]<<" ";
            }else if(f->getVertices()[3]->getName() == e3->getVertices()[1]->getName()){
                for (int i = e3->getCoEdges().size()-1; i >= 0 ; i--)
                    str << m_edge_ids_mapping[e3->getCoEdges()[i]->getName()]<<" ";
            }
            str << "]\n";
        }
        str << "\n";
}
/*----------------------------------------------------------------------------*/
void ExportBlocksImplementation::writeBlocks(std::ofstream &str, std::vector<Topo::Block*> blocks) {
        str  << "BLOCKS " << blocks.size() << "\n";
        for(auto b : blocks){
            const std::vector<Vertex*>& vertices = b->getVertices();
            int v0 = m_node_ids_mapping[vertices[0]->getName()];
            int v1 = m_node_ids_mapping[vertices[1]->getName()];
            int v2 = m_node_ids_mapping[vertices[2]->getName()];
            int v3 = m_node_ids_mapping[vertices[3]->getName()];
            int v4 = m_node_ids_mapping[vertices[4]->getName()];
            int v5 = m_node_ids_mapping[vertices[5]->getName()];
            int v6 = m_node_ids_mapping[vertices[6]->getName()];
            int v7 = m_node_ids_mapping[vertices[7]->getName()];

            const std::vector<Face*>& faces = b->getFaces();
            Face* f0 = faces[0];
            Face* f1 = faces[1];
            Face* f2 = faces[2];
            Face* f3 = faces[3];
            Face* f4 = faces[4];
            Face* f5 = faces[5];

            str << v0 << " " << v1 << " " << v2 << " " << v3 << " " << v4 << " ";
            str << v5 << " " << v6 << " " << v7 << " [ ";
            for (int i = 0; i < f0->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f0->getCoFaces()[i]->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f1->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f1->getCoFaces()[i]->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f2->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f2->getCoFaces()[i]->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f3->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f3->getCoFaces()[i]->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f4->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f4->getCoFaces()[i]->getName()]<<" ";
            str << "] [ ";
            for (int i = 0; i < f5->getCoFaces().size(); i++)
                str << m_face_ids_mapping[f5->getCoFaces()[i]->getName()]<<" ";
            str << "]\n";
        }
}
/*----------------------------------------------------------------------------*/
} // end namespace Geom
/*----------------------------------------------------------------------------*/
} // end namespace Mgx3D
/*----------------------------------------------------------------------------*/